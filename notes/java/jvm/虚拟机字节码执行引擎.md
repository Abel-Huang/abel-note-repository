## 虚拟机字节码执行引擎
虚拟机执行引擎针对字节码进行解析并且将输出执行结果。(针对字节码的执行可以是编译执行，也可以解释执行，
还可以两种方式都采用，如HotSpot采用的JIT编译技术)

### 运行时栈帧结构
栈帧是用于至此虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的 栈元素。
存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，
都对应着一个栈帧在虚拟机里面从入栈到出栈的过程。  
每一个栈帧都包含了局部变量表、操作数栈、动态链接栈、方法返回地址和一些额外的返回信息。
对于执行引擎来说，只有位于栈顶的栈帧才是有效的，称为当前栈帧(current stack frame), 这个栈帧关联的方法称为
当前方法，虚拟机执行的所有操作都只针对当前栈帧进行操作。

#### 局部变量表
局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量，以Slot为基本单位。
Slot一般为32位，可以存放boolean，byte，char， short，int, float, reference, returnAddress,
而long和double是64位，以两个Slot存储，高位对齐。
局部变量表中的数据位于虚拟机方法栈中，读写都是原子操作，不会存在线程安全问题。
为了节省栈帧空间，局部变量表中的Slot是可以复用的，如果当前字节码PC计数器的值已经超出了某个变量的作用域，
那么这个变量对应的Slot就可以交给其他变量使用。这样的副作用是可能会影响到系统的垃圾回收。

#### 操作数栈
用于存放方法运行时的数据，通过标准栈操作的出栈和入栈完成字节码的读取和写入内容操作。

#### 动态链接
指向该栈帧所属的方法的引用。

#### 方法返回地址
返回到方法被调用的位置。正常退出时调用者的PC计数器可以作为返回地址，异常退出时返回地址需要通过
异常处理表确定。

#### 附加信息
允许增加一些虚拟机规范中没有描述的信息到栈帧中。

### 方法调用
方法调用的任务是确定被调用方法的版本。与封装、继承、多态密切相关。

#### 解析
在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。  
解析调用是一个静态的过程，在编译阶段就可以确定。JVM提供了五条方法调用字节码指令。
* invokestatic: 调用静态方法
* invokespecial: 调用实例构造器<init>方法、私有方法和父类方法
* invokevirtual: 调用所有的虚方法
* invokeinterface: 调用接口方法，会在运行时确定一个实现此接口的对象
* invokedynamic: 调用动态解析出调用点限定符方法(Java7中用于增强动态语言，Java8用于实现lambda)

#### 分派
1. 静态分派
所有依赖静态类型来定位方法执行版本的分派动作成为静态分派。静态类型在编译期可知的，因此静态分派也是编译期
可知的。典型的实例是方法的重载，如果存在多个重载版本，会选择最合适的重载方法执行。

2. 动态分派 
与重写有着很密切的关联，运行时动态进行确定的。

### 动态类型语言的支持
静态类型语言是在非运行阶段，变量的类型是可以确定的，也就是说变量是有类型的。  
动态类型语言是在非运行阶段，变量的类型是无法确定的，变量没有类型但是值有类型，
运行期间可以确定变量的值的类型。
jdk1.7增加了invokedynamic指令用于增强对动态语言的支持。java.lang.invoke包。