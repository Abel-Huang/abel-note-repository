## Java内存模型-JMM(Java Memory Model)
### CPU多级缓存
#### 为什么需要CPU缓存
为了弥补CPU和主存之间的速度差异，缓解二者之间的速度的不匹配问题。

#### CPU缓存的意义
* 时间局部性： 如果某个数据被访问，那么在不久的将来它很可能会被再次访问
* 空间局部性：如果某个数据被访问，那么与它相邻的数据可有可能也会被访问。
 
#### CPU多级缓存的缓存一致性(MESI)
用于保证多个CPU Cache之间缓存共享数据的一致

#### 乱序执行优化
处理器为了提高运算速度而做出违背代码原有顺序的优化。
在单核处理器基本不会出现问题，但是在多核CPU中就可能会出现问题。

### Java内存模型
Java内存模型(JMM)的提出就是为了解决CPU多级缓存导致的数据不一致问题。

Java内存模型的主要目标是定义程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中
取出变量这样的底层细节。此处的变量与Java编程里面的变量有所不同步，它包含了实例字段、静态
字段和构成数组对象的元素，但不包含局部变量和方法参数，因为后者是线程私有的，不会共享，位于
Java虚拟机栈中当然不存在数据竞争问题（如果局部变量是一个reference引用类型，它引用的对象
在Java堆中可被各个线程共享，但是reference引用本身在Java栈的局部变量表中，是线程私有的）。
为了获得较高的执行效能，Java内存模型并没有限制执行引起使用处理器的特定寄存器或者缓存来
和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。

JMM规定了所有的变量都存储在主内存（Main Memory）中。每个线程还有自己的工作内存
（Working Memory）,线程的工作内存中保存了该线程使用到的变量的主内存的副本拷贝，
线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的
变量（volatile变量仍然有工作内存的拷贝，但是由于它特殊的操作顺序性规定，所以看起来如同
直接在主内存中读写访问一般）。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间
值的传递都需要通过主内存来完成

### 原子性
原子性是指一个操作是不可中断的。即使多线程一起执行，一个操作一旦执行就不会被其他线程干扰。

### 有序性
程序实际执行的顺序可能和代码的实际顺序不同。为了消除CPU执行指令的流水线操作上的"气泡"，会对指令进行重排序，指令重排可以使流水线更加顺畅。原则上指令重排不能改变原本的语义，是指令优化的一种方式。

### 可见性
可见性是指当一个线程修改了一个共享变量的值，其他线程是否能够立即知道这个修改。形成的原因非常复杂，可以有常见的以下几种：
* 编译器优化
* 硬件优化(写吸收，批操作)
* 虚拟机层面上面的优化

### Happen-Before规则
保证多线程的语义是一致的，即保证有序性
* 程序顺序规则： 一个线程内保证语义的串行性，按照代码顺序，书写在前面的操作先于书写在后面的操作
* 锁规则： 解锁(unlock) 必然发生在随后的加锁(lock)前
* volatile规则： volatile变量的写操作先发生于读操作，这保证了volatile变量的可见性
* 传递性： A先于B， B先于C, 那么A必然先于C
* 线程启动规则：线程的start()方法先于它的每一个动作
* 线程中断规则：线程的中断(interrupt()方法)先于被中断线程的代码检测到中断事件的发生
* 线程的终结规则：线程的所有操作先于线程的终结(Thread.join())
* 对象的终结规则：一个对象的初始化完成先行发生于它的finalize()方法的开始

### 线程安全
在多线程环境被调用时，能够正确的处理各个线程的局部变量，使程序能够正确完成。
