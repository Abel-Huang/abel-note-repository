## Redis缓存的用法

### 缓存的受益与成本
#### 受益
1. 加速读写
    * 通过缓存加速读写:CPU CACHE，浏览器缓存等
2. 降低后端的负载
    * 后端服务器通过前端缓存降低负载:业务端使用Redis降低后端MySQL负载

#### 成本
1. 数据不一致:缓存层和数据层有时间窗口的不一致，和更新策略有关
2. 代码维护成本：多了一层缓存逻辑
3. 运维成本：如Redis cluster

#### 使用场景
1. 降低后端负载
    * 对高消耗的SQL:join结果集/分组统计结果缓存
2.加速请求响应
    *利用Redis/Memcache优化IO响应时间
3. 大量读写合并为批量写
    * 如计数器先Redis累加再批量写DB
### 缓存更新策略
#### 缓存更新的思路
1. LRU(Least recently used，最近最少使用)/LFU(Least frequently used,最近使用次数最少)/
FIFO(First In First out, 先进先出)，例如maxmemory-policy    

2. 超时剔除:例如expire

3. 主动更新:开发控制生命周期

#### 建议
1. 第一执行:最大内存和淘汰策略(不推荐)

2. 高一致性:超时剔除和主动更新结合，最大内存和淘汰策略兜底(推荐)

### 缓存粒度控制
1. 通用性:全量属性更好
2. 占用空间:部分属性更好
3. 代码维护:表面上全量属性更好

### 缓存穿透问题(请求不命中)
1. 业务代码自身问题
2. 恶意攻击或者爬虫

#### 解决方案
1. 缓存空对象
    * 需要更多的键
    * 缓存层和存储层数据短期不一致
2. 布隆过滤器拦截
    
### 无底洞问题
增加机器后，执行效率和性能反而下降了
1. 更多机器！=更高的性能
2. 批量接口需求(mget,mset等)
3. 数据增长与水平扩展需求
#### 优化IO的方法
1. 命令本身的优化
2. 减少网络通信次数
3. 降低介入成本:连接池\NIO等

### 热点key重建优化


### CacheCloud 