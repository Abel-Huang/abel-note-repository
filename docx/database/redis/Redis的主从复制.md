## Redis的主从复制
### 为什么需要主从配置
* 单点故障
* 容量瓶颈
* QPS瓶颈

### 主从复制

#### 主从复制的基本作用
主从复制，读写分离
* 数据副本
* 扩展读性能

#### 简单总结
1. 一个master可以有多个slave
2. 一个slave只能有一个master
3. 数据流向是单向的，master到slave

### 主从复制的实现方法
#### 命令实现
1. 进行复制
在salve节点上执行如下命令：
```shell
slaveof <master host> <master port>
```
可以完成由主节点到从节点的异步复制，并且会清除slave上全部旧数据 
 
2. 取消复制复制
salve将不再成为master的从节点，不再进行复制，但是之前已经复制
过的数据是不会清除
```shell
slaveof no one 
```

#### 修改配置文件
在从节点的配置文件中进行配置，并且需要设置从节点是只读
```
slaveof ip port
salve-read-only yes
```

#### 两种方式的比较
| 方法  | 命令 |  配置文件  |
| -----   | -----:  | :----: |
| 有点   | 无需重启      |   统一配置    |
| 缺点   | 不便于管理      |   需要重启    |

#### 全量复制和部分复制
1. 全量复制
salve回向master发送请求，master本身的RDB文件同步给slave，而在同步期间，master写入的命令
也会记录下来（master内部有一个复制缓冲区，会记录同步时master新增的写入），
当slave将RDB加载完后，会通过偏移量的对比将这期间master写入的值同步给slave。
2. 全量复制的开销
    * bgsave时间
    * RDB文件网络传输时间
    * slave节点清空数据时间
    * slave节点加载RDB的时间
    * 可能的AOF重写时间
    
3. 部分复制
redis2.8版本之前，如果master和slave之间的网络发生了抖动连接断开，
就会导致slave完全不知道master的动作，同步就会出问题，而为了保证数据一致，
等网络恢复后进行一次全量复制。而全量复制的开销是很大的，redis2.8版本就
提个了一个部分复制的功能。  
当master和slave断开连接时，master会将期间所做的操作记录到复制缓存区当中
（可以看成是一个队列，其大小默认1M）。待slave重连后，slave会向master发送
psync命令并传入offset和runId，这时候，如果master发现slave传输的偏移量的值，
在缓存区队列范围中，就会将从offset开始到队列结束的数据传给slave，从而达到
同步，降低了使用全量复制的开销。

### 故障处理
主从复制是无法自动完成故障转移处理的
1. salve故障

2. master故障
(手动)重新选举一个新的master，选择一个节点执行slaveof no one, 其他节点
执行slaveof new master

### 主从复制开发运维中的常见问题
1. 读写分离
读流量分摊到从节点
    * 可能遇到的问题
        * 复制数据延迟
        * 读到过期的数据(3.2已解决)
        * 从节点故障
2. 主从配置不一致
    * 例如maxmemory不一致:丢失数据
    * 例如数据结构优化参数:内存不一致
3. 规避全量复制
    * 第一次全量复制
        * 第一次不可避免
        * 小主节点、低峰
    * 节点runId不匹配
        * 主节点重启(runId会发生变化)
        * 故障转移，如sentinel和cluster
    * 复制积压缓冲区不足(默认缓冲区只有1MB)
        * 网络中断，部分复制无法满足
        * 增大复制缓冲区大小的配置
4. 规避复制风暴
对于一个一主多从的结构，在master节点故障重启后，多个salve节点都会发生
复制，会造成非常大的开销
    * 单主节点复制风暴
        * 问题：主节点重启，多从节点复制
        * 解决：更换复制拓扑
    
    * 单机器复制风暴
        * 主节点分散多机器  

### 主从复制的局限性
1. 手动故障转移
    * 出现节点故障时需要手动进行故障转移
2. 写能力和存储能力受限
    * 写能力受限于master节点的写能力