## MySQL的索引优化
MySQL的索引是基于存储引擎实现的，不同的存储引擎支持和实现的索引不同。

### 为什么需要索引
1. 索引大大减少了存储引擎需要扫描的数据量
2. 索引可以帮助我进行排序以避免使用临时表
3. 索引可以把随机IO变为顺序IO以提升数据库的IO性能

### 索引是不是越多越好
1. 索引会增加写操作的成本(因为写数据时需要修改索引)
2. 太多的索引会增加查询优化器的选择时间

### MySQL支持的索引类型
#### B-tree索引
* B-tree索引是以B+树的结构存储数据
* B-tree索引能够加快数据的查询速度
* B-tree索引更适合进行范围查找
* B-tree索引是顺序查找的

##### 什么情况下可以用到B树索引
* 全值匹配的查询
* 匹配最左前缀的查询(针对于多个关键字的联合索引)
* 匹配列前缀查询(匹配某一列的开头部分)
* 匹配范围值的查询
* 精确匹配左前列并范围匹配另外一列
* 只访问索引的查询

##### B树索引的使用限制
* 如果不是按照索引最左列开始查找，则无法使用索引
* 使用索引时不能跳过索引中的列
* Not in和<>(不等于)操作无法使用索引
* 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引

#### Hash索引
* Hash索引是基于Hash表实现的，只有查询条件精确匹配Hash索引中的所有列时才能够使用到Hash索引
(也就是说不适用于模糊查询和范围查询)
* 对于Hash索引中的所有列，存储引擎都会为每一行计算一个Hash码，Hash索引中存储的就是Hash码

##### Hash索引的限制
* Hash索引必须进行二次查找(Hash索引本身不存放数据，只存放键值、hash码以及对应的指针，
不会存放对应的数据，必须要第二次重新查询数据)
* Hash索引无法用于排序
* Hash索引不支持部分索引查找也不支持范围查找
* Hash索引中Hash码的计算可能存在Hash冲突

### 索引优化策略
1. 索引列上不能使用表达式或函数

2. 前缀索引和索引列的选择性
    * eg:
    `CREATE INDEX index_name ON table(col_name(n))`
    针对列名的前n位前缀创建索引
    * 在选择前缀的位数时要保证索引的大小不能太大，又要保证索引的选择性不能太差
    * 索引的选择性是不重复的索引值和表的记录数的比值，即不重复的索引值越大越好
    
3. 联合索引
建立的索引不是越多越好，针对经常使用的多个字段可以考虑使用联合索引，
是由多个数据库字段组成的索引。
* 如何选择索引列的顺序
    * 经常会被使用到的列优先
    * 选择性高的列优先
    * 宽度小的列优先
    
4. 覆盖索引 
如果索引包含所有满足查询需要的数据的索引成为覆盖索引(Covering Index)，
也就是平时所说的不需要回表操作，只需要查询索引就可以返回数据
    * 优点
        * 优化缓存，较少磁盘IO操作(因为不需要查找到磁盘中的数据)
        * 可以减少随机IO，变随机IO操作为顺序IO操作
        * 可以避免对Innodb主键索引的二次查询
        * 可以避免MyISAM表进行系统调用
    * 无法使用覆盖索引的情况
        * 存储引擎不支持覆盖索引
        * 索引不支持覆盖索引(如Hash索引，索引本身只存储了键值对)
        * 查询中使用了太多的列(如 select * )
        * 使用了双%号的like查询(底层的API限制)
        
### 使用索引来优化查询
1. 使用索引扫描来优化排序
    * 通过排序操作
    * 按照索引顺序扫描数据
        * 索引的列顺序和Order by字句的顺序完全一致
        * 索引所有列的方向(升序,降序)和Order by字句完全一致
        * Order by中的字段全部在关联表中的第一张表中

2. 模拟Hash索引优化查询
对于不支持Hash索引的引擎可以使用B-tree模拟Hash索引
    * 只能处理键值的全值匹配查找
    * 所使用的Hash函数决定着索引键的大小
    
3. 通过索引优化锁
    * 索引可以减小锁定的行数
    * 索引可以加快处理速度，同时也加快了锁的释放

### 索引的而维护和优化
1. 删除重复和冗余的索引
2. 查找未被使用过的索引
3. 更新索引统计信息及减少索引碎片
