# 数据库锁
锁是计算机协调多个进程或线程并发访问某一资源的机制，锁保证数据并发访问的一致性，有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是 MySQL 在服务器层和引擎层面的并发控制。数据库并发会引发很多问题，数据库通过锁机制解决并发访问问题。
* 根据锁定对象的不同一般来可以分为表级锁和行级锁，前者对整张表进行锁定，后者对表中特定行进行锁定。
* 根据锁定的关系来看，可以分为共享锁和独占锁。
* 根据所的实现原理可以分为悲观锁和乐观锁
* 枷锁是消耗资源的，锁的各种操作，包括获得锁、检测锁是否已经解除，释放锁等。

## 锁机制
### 共享锁和排他锁
1. 共享锁(读锁)：
其他事务可以读，但不可以写；
2. 排他锁(写锁)：
其他事物不能读取，也不能写。
### 锁粒度
对于 InnoDB 而言，既支持行级锁也支持表级锁，但是默认情况下采用的是行级锁。默认情况下，表锁和行级锁都是自动获取的，不需要额外的名命令。
#### 不同粒度的锁的比较：
* 表级锁：
开销小，加锁快；不会出现死锁，锁定粒度大，发生锁冲突的概率高，并发度最低；
    * 存储引擎总是一次性获得所有需要的锁以及总是按照相同的顺序获取表锁来避免死锁；
    * 表级锁适合查询为主，并发用户少，只有少量安索引条件更新数据的应用，比如web应用；
* 行级锁：
开销大，加锁慢，会出现死锁；锁定粒度最小，发生冲突的概率最低，并发度最高。
    * 最大程度的支持并发，同时也带来了最大的锁开销；
    * 在 InnoDB 中，除了单个 SQL 组成的事务外，锁是逐步获得的，这也说明在 InnoDB 中死锁是可能的。
    * 行级锁只在存储引擎层实现，而 MySQL 服务器层没有实现，适用于有大量安索引条件并发更新少量不同数据，同时又有并发查询的应用。
* 页面锁：
介于行级锁和表锁之间。

### InnoDB 的锁
#### InnoDB 行锁
行锁具体实现为共享锁和排他锁。
行锁是通过给索引上的索引项枷锁来实现的，也就说明 InnoDB 只有通过索引条件检索数据才能使用行级锁，否则只能使用表级锁。
#### InnoDB 表锁

#### InnoDB 的间隙锁
当需要进行范围查找并请求共享或者排他锁时，InnoDB 会给出符合条件的已有数据记录的索引项枷锁；即使在这个范围内，但是实际上并不存在的记录也会被枷锁，称为间隙锁。
间隙锁主要目的是为了防止幻读，以满足隔离级别的需要，满足恢复和复制的需要。

### 死锁


## MVCC
MySQL 的大多数事务型存储引擎实现都不是简单的行级锁，基于提升并发性能的考虑，一般都使用了多版本并发控制，也称为数据多版本数据库，不用加任何锁，通过一定的机制生成一个数据请求时间点的一致性数据快照，并用这个快照提供一定的事务隔离机制来解决。不管实现时间多长，每个事务看到的数据都是一致的。
分为乐观并发控制和悲观并发控制。

### 实现
InnoDB 的 MVCC 是通过在每行记录后面保存两个隐藏的列来实现，分别是行的创建时间和行的过期时间，这个时间并不是真实的时间而是系统版本号(system version number)。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来查询到每行记录的版本号进行比较。 