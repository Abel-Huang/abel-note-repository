## Java并发问题
1. 线程终止
线程终止一般有三种方式
    * run()方法执行完，自然终止，使用退出标志，使线程正常退出；
    * 调用stop()方法，强制终止(不推荐)；
    * 调用interrupted()方法中断线程。
每一个线程都有一个boolean类型标志，用来表明当前线程是否请求中断，当一个线程调用interrupt() 方法时，线程的中断标志将被设置为true。
我们可以通过调用Thread.currentThread().isInterrupted()或者Thread.interrupted()来检测线程的中断标志是否被置位。这两个方法的区别是：Thread.currentThread().isInterrupted()是线程对象的方法，调用它后不清除线程中断标志位；而Thread.interrupted()是一个静态方法，调用它会清除线程中断标志位。

2. 线程安全
如果在多线程下执行的结果与在单线程下执行的结果一致，并且不会出现数据不一致的问题，就可以认为是线程安全的。
线程安全问题都是由全局变量及静态变量引起的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。如何保证线程安全：
    * 线程同步，如加锁
    * 使用线程安全的类
    * 使用原子类
    * 使用线程局部变量

3. sleep()和wait()方法
sleep() 方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞争cpu的执行时间，sleep()不会释放锁；
wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通过notify悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。[1]
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。，notifyAll方法来唤醒等待的线程。
综上：sleep() 和 wait() 的区别就是 调用sleep方法的线程不会释放对象锁，而调用wait() 方法会释放对象锁。

4. CAS
CAS 不通过JVM,直接利用java本地方 JNI（Java Native Interface为JAVA本地调用）,直接调用CPU 的cmpxchg（是汇编指令）指令。
CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。
CAS在冲突较少的情况下，性能较高，但是在冲突较多的情况下直接使用的锁的效果会更好。

5. 悲观锁和乐观锁
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。乐观锁不能解决脏读的问题。

6. AQS
同步队列。维护了一个volatile int state（代表共享资源）和一个FIFO线程等待队列(多线程争用资源被阻塞时会进入此队列),其中state在不同的子类中表示不同的含义，如在ReentrantLock中，这个state表示的是当前占有锁的线程的次数(即重入的次数)，每次该线程进入就会+1，释放就会-1，直到state为0，这时其他线程就可以继续竞争锁。

7. synchronized关键字用法
    * 修饰代码块，如一个对象中的synchronized(this){} 部分，其他试图访问该对象的线程将会被阻塞；
    * 修饰实例方法，作用域是当前实例方法，作用对象是调用这个方法的对象；
    * 修饰类，其作用范围是synchronized后面的括号的部分，作用的对象是这个类的所有对象；
    * 修饰静态方法，作用范围是整个静态方法，作用的对象是这个类的所有对象。

8. 死锁及其产生
死锁是指两个或以上的进程再执行过程中，因争夺资源可造成的一种互相等待的现象，若无外力作用，将会持续这种死锁状态。
产生死锁原因：
    * 系统资源不足
    * 进程运行推进顺序不合适
    * 资源分配不当

9. 死锁的预防(进程可以换成线程)
产生死锁有四个必要条件，即出现死锁是肯定有这四种条件，但是有这种四种条件不一定会产生死锁，预防死锁就是破坏其中一个或者多个条件即可。
    * 互斥条件：所谓互斥就是进程在某一时间段独占资源
    * 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放
    * 不剥夺条件：进程已获得资源，在未使用完之前，不能进行剥夺
    * 循环等待条件：若干进程之间形成了一种头尾相连的循环等待资源关系

10. 关于volatile关键字
    1. volatile数组  Java中可以创建volatile数组，但是只是指向这个个数组的引用，而不是整个数组，如果改变引用指向的数组，将会受到volatile的保护，如果多线程下改变数组的元素，volatile不能起到保护的作用；
    2. volatile不能使一个非原子操作变成一个原子性操作，volatile保证内存可见性。但是对于一个原本非原子性的操作(long和double的读写)可以使用volatile修饰，使其成为一个原子性操作(long和double都是64位，一次只能取一半)；
    3. volatile的作用，通过volatile修饰变量可以提供有序性和可见性保证，使用volatile修饰后不会因为JVM或JIT由于优化代码而进行重排序，提供了happens-before保证，确保一个线程对volatile变量的修改对其他线程是可见的。

11. 线程局部变量 ThreadLocal  
ThreadLocal可以为使用相同变量的每个不同的线程创建不同的存储，每个线程可以独立的维护和改变自己的副本而不会影响到其他线程所对应的副本，ThreadLocal可以实现线程隔离的原因在于ThreadLocal的静态内部类。
ThreadLocal的方法， void set(T value), T get()以及T initialValue()等；
ThreadLocal如何为每个线程创建变量的副本：
首先，在每个线程Thread内部都有一个ThreadLocal.ThreadLocalMap类型的成员变量threadLocals，用于存储当前ThreadLocal和变量副本value(T类型的变量)的键值对。初始时，threadLocals为空，通过ThreadLocal变量调用get()或set()方法，就会对Thread类中的threadLocals进行初始化，并且以当前ThreadLocal变量为key，以ThreadLocal要保存的副本变量为value，存放在threadLocals中。在当前线程中，可以通过get()方法获取存放在threadLocals中的当前线程副本变量。
    总结：
    1.  实际的通过ThreadLocal创建的副本都是存储在每个线程自己的threadLocals(ThreadLocal.ThreadLocalMap)中；
    2.  为何threadLocals中key选择ThreadLocal对象而不是Thread本身，因为一个线程中可能有多个ThreadLocal对象；
    3.  使用get()之前必须先使用set()，否则会出现空指针异常；如果在get之前不需要调用set()就能正常访问，必须重写initialValue()方法。
