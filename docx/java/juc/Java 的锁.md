# Java 的锁

## 偏向锁

## 自旋锁
1.基于乐观情况下推荐使用，即锁竞争不强，锁等待时间不长的情况下推荐使用；
2.单cpu无效，因为基于cas的轮询会占用cpu,导致无法做线程切换；
3.轮询不产生上下文切换，如果可估计到睡眠的时间很长，用互斥锁更好。

## 轻量级锁


## 锁的膨胀和升级
偏向锁 -> 轻量级锁 -> 重量级锁(互斥锁)

## 死锁
多个线程(或依赖共同资源的进程)彼此循环依赖资源导致会一直处于等待之中，所有的实体都不能继续执行，处于阻塞的状态
就被称为死锁。
在Java程序中可以通过 jstack 进行死锁的定位。

### 死锁发生的条件
1. 互斥条件，资源都是互斥的；
2. 互斥条件是长期持有的，在使用结束之前自己不会释放，也不会被其他线程抢占；
3. 循环依赖，两个或者多个线程之间出现了锁的链条环。

### 避免死锁
1. 避免使用多个锁，只有在需要时才会持有锁；
2. 如果必须使用锁，需要设计好锁的获取顺序；
3. 使用带超时的锁，为程序带来更多的可控性；
4. 可以通过一些代码分析的方法去进行锁的判断。