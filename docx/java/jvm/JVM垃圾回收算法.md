# JVM 垃圾回收算法
## GC 的概念
GC 就是对已经分配的内存进行回收，Java 中主要是针对堆空间和永久区。
## 如何判断对象是否需要回收
* 引用计数法
* 可达性分析法

### 引用计数法
缺点：
1. 性能比较差；
2. 无法解决循环引用问题。

### 可达性分析法
只有通过 GCRoot 可达的点，才认为是真正被引用的，其他的都认为是不可达的，可以进行垃圾回收。
GCRoot：
1. 栈中引用的对象
2. 全局对象
3. 本地方法栈中引用的对象

### 可触及性
1. 可触及
2. 可复活的
3. 不可触及的

## 垃圾回收算法
* 标记-清除算法
* 复制算法
* 标记-整理算法
### 标记-清除算法
分为标记和清除两个阶段，先进行对象标记，然后进行垃圾的回收。
缺点：
1. 产生大量的内存碎片；
2. 标记和回收的效率比较低。
### 复制算法
将原有的内存空间分为两块，每次只使用一块。
缺点：
1. 空间浪费 2.如果对象存活率较高会对性能产生较大的影响。
改进：
分代，新生代分为 2 个 survivor 和 eden 区，复制只在两个 survivor 区之间进行，这样复制算法
只会浪费一个 survivor 区域的空间。

### 标记-整理算法
分为三个阶段，先进行对象标记，然后将存货对象复制到另外内存的一端，对另外一端的内存进行清除。

### 分代思想
根据对象的存活周期进行对象分代，短命对象分为新生代，长命归为老年代。
根据不同代的不同特点，采取合适的垃圾收集算法：
* 少量对象存活，适合复制算法；
* 大量对象存活，适合标记清除或标记整理。

## 垃圾回收的过程
1. Java 应用创建对象，一般会分配在 Eden 区域，当占用空间达到一定的阈值时会触发 minor GC，存活的对象会被复制到Survivor，而没有被引用的
对象则会被回收，存活对象年龄计数加一；
2. 等到下次触发 minor GC，另外一个 Survivor 就会成为 to 区域，Eden 和 from 区域的存活对象会被复制到 to区域，所有存活对象年龄计数加一；
3. 当新生代存活对象的年龄计数达到一定的阈值，就会进行晋升，超过阈值的对象就会进入到老年代；
4. 当老年代的 GC 达到阈值后，会触发 Full GC，老年代也会进行GC。 

## Stop-The-World
Java 中一种全局暂停的现象，全局暂停，所有的 Java 代码停止， native 代码可以执行， 但是不能和 JVM 交互。
### 产生原因
* Stop-The-World 多半是由 GC 引起；
* Dump 线程；
* 死锁检查；
* 堆 Dump。