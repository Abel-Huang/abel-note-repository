## JVM笔记1:内存结构

### 入门基础
#### jdk，jre和jvm
jdk包含了jre和jvm。
* jre：Java Runtime Environment
* jvm：Java Virtual Machine

#### JVM监控工具
* jps：监控Java的进程和端口号
* jConsole：jdk自带的可视化性能监控程序，可以监控包括内存，线程，类等

#### Java技术体系
* Java程序设计语言
* 各种硬件平台上的JVM
* Class文件格式
* Java API
* 第三方的Java类库

#### Java8的新特征


#### JVM的种类

### 内存结构
#### JVM的基本结构




##### 程序计数器
* 是一个比较小的内存空间，可以看成当前线程执行字节码的行号计数器。
* 位于线程独占区
* 用户无需操作程序计数器，所以这块区域是不会发生内存溢出的，Java虚拟机规范也没有规定这块会发生OutOfMemoryError。
* 如果线程执行的是Java额方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果执行的是naive方法，这个计数器的值为undefined。

##### 虚拟机栈
* 描述Java方法执行的动态内存模型
* 栈帧 
    * 每个方法执行都会创建一个栈帧，并且放入栈中，运行时会出栈，并且会被销毁。
    * 用于存储局部变量表，操作数栈，动态链接，方法出口等
* 局部变量表
    * 存放编译期可知的各种基本类型，引用类型，返回类型
    * 局部变量表的内存空间大小在编译期完成分配，运行期间是不会改变局部变量表的大小
* 虚拟机栈栈帧过深有可能会导致StackOverflowError， OutOfMemory

##### 本地方法栈
* 本地方法栈是为虚拟机执行native方法服务的，其余与虚拟机方法栈类似。在HotSpot中两者在一起，统称为方法栈


##### Java堆
* 堆内存是线程共享的
* Java堆是JVM管理的最大的一块内存
* 用于存放对象的实例
* 垃圾回收的主要区域
* 会抛出OOM

##### 方法区
* 存储虚拟机加载的类信息， 常量， 静态变量， 即时编译后产生的代码等
    * 类的版本
    * 字段
    * 方法
    * 接口
* 方法区和永久代
    * HotSpot中永久代在方法区中，Java8中HotSp已经移除了永久代，其他的JVM并没有存在永久代
* 方法区也会出现垃圾回收，但是回收的效率远低于Java堆
* 也会抛出OOMError
* 运行时常量池位于方法区中，最常见的如String类中使用的常量池, 当内存缺乏时，申请运行时常量池也会出现OOMError
* 直接内存分配时也会出现OOMError

#### 关于Java对象
##### 对象的创建
具体流程如下：

##### 对象的内存分配
* 指针碰撞  (适用于内存比较规整)
* 空闲链表  (适用于内存不规整)

##### 创建对象的线程安全性问题
在对象分配内存时多个线程可能会造成内存分配时出现线程安全问题
* 线程同步(加锁，但是会降低吞吐量)
* 本地线程分配缓冲(TLAB, ThreadLocal Allocate Buffer)

##### 对象的结构
包含Header， InstanceData， Padding

* header(对象头)
    * 自身运行时数据(Mark Word) 32位JVM是32位， 64位JVM是64位
        * 哈希值， GC分代年龄，锁状态标志，线程持有的锁， 偏向线程ID， 偏向时间戳
    * 类型指针
* InstanceData(对象的实例)
    * HotSpot会把相同宽度的字段分配在一起，如long和double分配在一起
* Padding
对象的长度必须是8个字节的整数倍，Padding存放的是填充位

##### 对象的访问定位
引用和对象的访问定位方式
* 使用句柄： 先指到一个句柄池(堆中单独的一块内存)，然后再定位到实际的内存
* 直接指针 ：直接地址到实例












