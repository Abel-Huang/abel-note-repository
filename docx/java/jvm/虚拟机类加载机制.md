# 虚拟机类加载机制
## 概述
虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的Java类型，就是虚拟机的类加载机制。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
通过一个类的全限定名来获取描述此类的二进制字节流，这个动作被放到 Java 虚拟机外部去实现，以便由程序自己决定如何去获取所需要的类，实现这个动作的代码称为 "类加载器" 。
## 类加载的时机
类加载的时机包括加载，验证，准备，解析，初始化，使用和卸载七个阶段。  
其中 验证、准备、解析3个部分称为连接，那么就可以将类加载的步骤分为：加载、链接、初始化。
加载、验证、准备、初始化和卸载五个部分顺序固定，只有解析的顺序不是固定的，甚至可以在初始化之后进行方便进行Java
语言的运行时绑定。
* 虚拟机严格规定了类初始化的时机，有且只有这五种情况：
1. 遇到 new，getstatic，putstatic 和 invokestatic 四条字节码指令时，如果类没有初始化，则需要先触发其初始化。
    * 生成这四条指令最常见的情形：使用new关键字实例化对象，读取或设置一个类的静态字段(被final修饰的常量字段除外) 以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有初始化，则需要先触发其初始化。
3. 初始化一个类时，如果发现其父类没有初始化，则需要先触发其父类的初始化。
4. 虚拟机启动时，需要初始化main方法所在的那个类。
5. 在JDK1.7以后，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic, REF_putStatic,
REF_invokeStatic的方法句柄对应的类没有初始化，则需要先触发其初始化。


## 类加载的过程
### 类加载的过程
#### 加载
1. 加载-Loading
将字节码从不同的数据源读取到JVM中，并映射为JVM认可的数据结构(Class对象)
* 通过类的全限定名获得定义此类的二进制流
    * 从zip包中获取，如JAR，WAR
    * 从网络中获取，如Applet
    * 运行时计算生成，如动态代理
    * 其他文件生成，如JSP
* 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
* 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的这个类的各种数据的访问入口

#### 链接-Linking
把原始的类定义信息平滑地转化到JVM运行的过程中。
1. 验证(连接)
确保被加载类的正确性。
确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的危害。
验证和加载并不是串行的，加载尚未完成，连接可能已经开始了。
验证并不是必须的，可以通过一些参数设置跳过虚拟机验证
    * 文件格式校验
        * 魔数，版本号，常量等等，校验是符合Class文件的格式等
    * 元数据校验
        * 是否有父类，是否继承final类等
    * 字节码校验(最复杂)
        * 通过数据流和控制流，确定程序语义是合法的，符合逻辑的等
    * 符号引用校验
        * 对常量池中各种符号引用进行匹配性校验等
 
 2. 准备(连接)
正式为类变量(静态)分配内存并设置变量的初始值，这些变量的内存都将在方法区中进行分配。
这里的初始值并非我们制定的值，而是其默认值。如int为0，bool为false，float为0.0，引用类型为null。
而对于final修饰的常量，常量值会被初始化为指定的常量值。

3. 解析(连接)
解析阶段是虚拟机将常量池的符号引用替换为直接引用的过程。
符号引用：用符号描述的引用的目标，可以是任何形式的字面量，使用时只要能无歧义的定位到目标即可。
直接引用：直接引用可以是直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄。
* 类或接口的解析
    * 不是一个数组类型
    * 是一个数组类型
    * 如果没有出现异常，就会是一个有效的类或者接口了，在解析完成之前还要进行符号引用的验证，
    确认是否有访问权限。
* 字段解析
    * 需要先完成类的解析
* 类方法的解析
    * 需要先完成类的解析
* 接口方法解析
    * 需要先完成类或者接口的解析

####  初始化    
1. 初始化
初始化是类加载的最后一步。
初始化结算是执行类构造器<clinit>()方法的过程。
* 编译器收集的顺序，静态语句块中(static{})只能访问到定义在静态语块之前的变量，定义在后面的变量，
可以在前面的静态代码块中赋值，但是不能访问，编译器会提示：非法向前引用。
* 虚拟机会保证在子类执行<clinit>()方法之前父类的<clinit>()方法已经执行完毕，因此JVM中第一个执行的肯定是
java.lang.Object
* 父类的静态代码块要先于子类的静态代码块执行
* 如果一个累没有静态语句块，也没有对变量生成<cinit>()方法
* 接口中不能使用静态语句块，但是仍然有变量初始化的复制操作，因此接口与类一样都会生成<cinit>()方法
* <cinit>()方法在多线程中能被正确的加锁、同步，是线程安全的。如果一个类的<cinit>()方法执行时间过长可能会造成
多个进程阻塞。(说明这个方法是个同步方法)

## 结束生命周期
– 执行了System.exit()方法
– 程序正常执行结束
– 程序在执行过程中遇到了异常或错误而异常终止
– 由于操作系统出现错误而导致Java虚拟机进程终止

## 类加载机制
1. 全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由
该类加载器负责载入，除非显示使用另外一个类加载器来载入
2. 父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类
3. 缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，
类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，
并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效

## 双亲委派加载模型的意义
1. 防止重复加载，内存出现多分相同的字节码；
2. 保证程序安全稳定运行。

