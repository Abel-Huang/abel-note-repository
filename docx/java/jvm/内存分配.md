## JVM内存分配

### 一些基本概念
* Minor GC 发生在新生代的GC
* Full GC 发生在老年代的GC 可以由系统调用或者用户自己调用

### 内存分配策略
* 优先分配到Eden区
    * 在Eden区域经历了Minor GC后，存活下来的对象会复制到Survivor区，多次GC后存活的对象会转移到老年代中，
    如果对象太大，无法全部放到Survivor区中，可以由老年代进行分配担保，消耗老年代的内存。
* 大对象直接分配到老年代
    * 可以由参数 `PretrnureSizeThreshold`控制直接进入老年代的对象的大小, 超出这个阈值后会直接分配到老年代
* 长期存活的对象分配到老年代
    * 一个对象每次在Survivor去中一次MinorGC中存活下来，年龄就会增加一， 达到一定的阈值后就会将对象晋升到老年代中
    * 使用 `-XX:MaxTenuringThreshold='设置晋升到老年代的年龄阈值
* 空间分配担保
    * `-XX:+HandlerPromotionFailure` 打开空间分配担保的设置
* 动态对象年龄判断
 
 ### 逃逸分析和栈上分配
 1. 栈上分配  
   将内存分配在栈上，不需要虚拟机进行垃圾的回收。
    * 说明 栈上分配是java虚拟机提供的一种优化技术，基本思想是对于那些线程私有的对象（指的是不可能被其他线程访问的对象），可以将它们打散分配在栈上，而不是分配在堆上。
    * 好处 分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提供系统的性能。
2. 逃逸分析
    栈上分配的一个技术基础是进行逃逸分析，逃逸分析的目的是判断对象的作用域是否有可能逃逸出函数体。
   * 对象的作用域仅仅在当前方法中有效，没有发生逃逸
   * 引用成员变量的值或者为成员变量赋值都会发生逃逸
   * 一个局部变量如果没有发生引用逃逸可以将该变量分配在栈上，从而提升系统性能