# RabbitMQ 高级特征
 
 ## 消息如何保障 100% 的投递成功
 ### 什么是生产端的可靠性投递
 1. 保障消息成功发出
 2. 保障 MQ 节点成功接收
 3. 发送端收到 MQ 节点 (Broker) 确认应答
 4. 完善的消息进行补偿机制
 
 ### 业界解决方案
 1. 消息入库，对消息状态进行打标
    * 消息和业务信息持久化，一般是存入数据库；
    * producer 发送消息；
    * MQ Broker 发送确认消息给 producer；
    * 对已经确认的消息进行状态修改；
    * 有一个定时任务会在数据库里面轮询，查找一定时间内状态没有
    修改(即没有确认的消息)；
    * Retry，重新发送上一步中检测到未修改的消息；
    * 设置 Retry Count > 3, 进行其他标示性操作。
    * 可能在高并发场景下对磁盘 IO 压力很大，不适应于大流量的
    高并发操作。
    
 2. 消息的延迟投递，做二次确认，回调检查(高并发下推荐使用)
    * 对业务消息入库，然后第一次将消息投递到 MQ Broker；
    * 延迟发送同样的消息，即延迟投递；
    * consumer 监听 Broker 的消息；
    * 下游服务在收到消息后，会生成一个新的确认消息发送到另外一个
    queue 中；
    * 单独的补偿服务会监听确认消息，并且进行入库；
    * 补偿服务也会监听延迟投递的消息，检查数据库中是否有相同的数据，
    如果已经查到数据，此时原始消息就是已经是投递成功了，否则补偿服务
    需要进行数据补偿将消息通过 rpc 发送到上游服务进行 retry， 在进行
    一次消息的发送。
 
 ## 消息的幂等性
 消息的幂等就是需要避免出现消息重复消费问题。即使消费端收到多条相同的消息，
 也不会消费多次，尽可能做到 "at extracly once"。
 
 ### 业界主流的幂等性操作
 1. 唯一ID + 指纹码机制；
    * 唯一ID + 指纹码机制，利用数据库主键去重，唯一 ID 可能是业务的 ID；
    * 通过判断该键是否存在来确定是否已经存在；
    * 优点: 实现简单
    * 缺点：高并发下有数据库写入的性能瓶颈问题；
    * 解决方案：根据 Id 进行分库分表，进行算法路由。
 2. 利用 Redis 的原子性进行去重。