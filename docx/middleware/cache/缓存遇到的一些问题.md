# 缓存遇到的一些问题
## 缓存一致性
### 缓存一致性问题的出现原因
1. 更新数据库成功 -> 更新缓存失败 -> 数据不一致
2. 更新缓存成功 -> 更新数据库失败 -> 数据不一致
3. 更新数据库成功 -> 淘汰缓存失败 -> 数据不一致
4. 淘汰缓存成功 -> 更新数据库失败 -> 查询缓存 Miss

## 缓存并发问题
在并发场景下多个线程/进程同时获取缓存，可以使用锁的机制，将查询数据库和重建索引这两个步骤进行上锁，此时其他的获取缓存的操作都会被阻塞。

## 缓存穿透问题
高并发场景下某个请求没有命中缓存(查询一个不存在的数据)，处于容错性的考虑，这时会尝试从数据库中获取数据，如果这时数据库中没有这个值，就会导致数据库中进行了很多不必要的查询操作，导致数据库压力过大。
1. 缓存空对象，对查询结果为空的对象也进行缓存，避免穿透到后端数据库，直到缓存过期或者有真实的值填充上；
2. 单独过滤处理，如使用布隆过滤器。对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端数据库。这种方式实现起来相对复杂，比较适合命中不高，但是更新不频繁的数据；
3. 也可以给 key 设置一些格式规则，然后查询之前先过滤掉不合规则的 key。

## 缓存雪崩
### 缓存抖动问题
缓存的颠簸问题，有些地方可能被成为“缓存抖动”，可以看做是一种比“雪崩”更轻微的故障，但是也会在一段时间内对系统造成冲击和性能影响。一般是由于缓存节点故障导致。业内推荐的做法是通过一致性Hash算法来解决。

### 缓存雪崩问题
缓存雪崩就是指由于缓存的原因(数据未加载到缓存中或者缓存同一时间大面积的失效)，导致大量请求到达后端数据库，从而导致数据库崩溃。导致这种现象的原因有很多种，上面提到的“缓存并发”，“缓存穿透”，“缓存颠簸”等问题，其实都可能会导致缓存雪崩现象发生。这些问题也可能会被恶意攻击者所利用。还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。
#### 缓存雪崩的解决思路
1. 从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难；
2. 此外，从整个研发体系流程的角度，应该加强压力测试，尽量模拟真实场景，尽早的暴露问题从而防范；
3. 缓存的高可用设计，防止缓存大面积故障，即使单点出现问题也不会影响整个集群。

## 缓存预热
缓存预热就是在系统上线后，将相关的缓存数据直接加载到缓存系统，这样可以避免用户在请求的时候先查询数据库，然后再将数据缓存的问题，用户可以直接查询实现被预热的缓存数据。
解决思路：
1. 手动操作进行缓存的刷新；
2. 项目启动时自动进行加载，适用于数据量不大的时候。

## 缓存过期策略
1. FIFO（First In First out）：先见先出，淘汰最先近来的页面，新进来的页面最迟被淘汰，完全符合队列，可用数据结构上的队列来实现：
    1. 新访问的数据插入FIFO队列尾部，数据在FIFO队列中顺序移动；
    2. 淘汰FIFO队列头部的数据。
2. LRU（Least recently used）:最近最少使用，淘汰最近不使用的页面，最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：
    1. 新数据插入到链表头部；
    2. 每当缓存命中（即缓存数据被访问），则将数据移到链表头部；
    3. 当链表满的时候，将链表尾部的数据丢弃。
3. LFU（Least frequently used）:）根据数据的历史访问频率来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。
    1. 新加入数据插入到队列尾部（因为引用计数为1）；
    2. 队列中的数据被访问后，引用计数增加，队列重新排序；
    3. 当需要淘汰数据时，将已经排序的列表最后的数据块删除。
    
### Redis 过期键删除策略
1. 定时删除
设置键的过期时间时，创建一个 Timer，当过期时间到临时，立刻删除键。内存友好型策略，一旦键过期，就会被删除，并释放所占用的内存，Cpu 不友好，当一批数量比较多的键过期时，正好遇上Cpu 紧张的时段，这时候需要的是 Cpu 处理能力，而不是内存，显然 Cpu 时间用在删除过期键上，会对服务器的响应时间和吞吐量造成影响。另外当前 Redis 时间事件（无序链表O(N)）无法高效处理大量时间事件，所以定时删除并不是一种好的定时删除策略。

2. 惰性删除
不管过期的键，在这种策略下，当键在键空间中被取出时，首先检查取出的键是否过期，若过期删除该键，否则，返回该键。
 很明显，惰性删除依赖过期键的被动访问，对于内存不友好，如果一些键长期没有被访问，会造成内存泄露（垃圾数据占用内存）。我们知道，Redis是依赖内存的，所以惰性删除也不是一个好的策略。
   
3. 定期删除(Redis 采用的方式)
由定时删除算法，定期的去检查一定的数据库，删除一定的过期键。 通过合理的删除操作执行的时长和频率，达到合理的删除过期键。
 