# 缓存一致性问题
## 如何保证数据库与缓存双写时的一致性问题
### cache aside pattern
1. 什么是 cache aside pattern
读的时候先读缓存，缓存没有的话就去读数据库，然后取出数据放入缓存中，同时返回响应；
更新的时候，先删除缓存，然后再更新数据库。

2. 为什么是删除缓存，不是更新缓存呢？
因为缓存的值可能计算比较复杂，不是简单的从数据库中取出值，更新缓存的代价比较高。

3. 先修改数据库，再删除缓存，如果删除缓存失败，会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。
解决思路：
先删除缓存，再修改数据库，如果删除缓存成功，修改数据库失败，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候没有缓存，则读取数据库中的旧数据，然后更新到缓存中。

3. 数据库发生了变更，先删除了缓存，然后取修改数据库，此时还没有修改，此时有请求，先去读缓存，会发现缓存中没有数据，这时会继续去读数据库中的数据(此时还未更新完，仍然是旧数据)，并且将数据库中读到的数据写入缓存，数据库在
经过数据变更之后变为新值，此时出现数据不一致。
解决方案：
更新数据的时候根据数据的唯一标示，将操作路由后发送到一个 JVM 内部的队列中，读取数据的时候如果发现数据不在缓存
中，那么重新读取数据+更新缓存的操作，根据唯一标示路由，也发送同一个 JVM 内部的队列中，一个队列对应一个工作线
程，每个工作线程拿到对应的操作，然后串行执行。这种情况下，一个数据变更的操作，先执行，后删除缓存，然后再去更新数据库，但是还没有完成更新，此时如果一个读请求过来，读到空的缓存，可以先将缓存更新的请求发送到队列中，此时会
在队列中积压，然后同步等待缓存更新完毕。