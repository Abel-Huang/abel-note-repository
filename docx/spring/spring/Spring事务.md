## Spring事务
 在Spring中，数据库事务是通过PlatformTransactionManager进行管理的。

### 数据库事务
数据库事务有严格的定义，必须同时满足4个特性:原子性、一致性、隔离性和持久性，简称ACID。
* 原子性： 表示组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作执行成功，整个事务才会提交。任何一个数据库操作失败，已经执行的所有操作都必须撤销，返回初始状态。
* 一致性：事务操作成功后，数据库所处的状态和它的业务规则是一样的，事务必须始终处于一致的状态，确保数据不会被破坏。如转帐时，两个账户的存款总额。
* 隔离性：指两个事务之间的隔离程度，在并发操作数据时，不同事务拥有各自的数据空间，它们的操作不会对对方产生干扰。数据库规定了多种事务隔离级别，不同级别对应不同的干扰程度，隔离级别越高，数据一致性越好，并发性越弱。
* 持久性：事务完成后，事务中的所有数据会提交到数据库中并不会被回滚。

其中一致性是最终目的，其他特性都是为达到目标而采取的措施、要求或手段。
数据库管理系统一般采用重执行日志来保证原子性、一致性和持久性。采用锁机制保证事务的隔离性。
 
#### 数据并发问题
在并发环境下，数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，主要可以分成五类，其中3类数据读问题(脏读、不可重复读、幻读)及两类数据更新问题(第一类丢失更新和第二类丢失更新)
1. 脏读(dirty read)
A事务读取到B事务未提交的事务，被称为脏读。

2. 不可重复读(unrepeatable read)
是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据，这是由于查询时其他事务修改的提交造成的。

3. 幻读(phantom read)
A事务读取B事务提交的新增数据，如果新增数据刚好满足事务的查询条件，那么这个新数据就会进入事务的视野，因此产生了两次结果不一致的情况。

4. 第一类丢失更新
有两个事务并发执行，事务A回滚，事务B提交成功导致数据不一致，称为第一类丢失更新。
第一类丢失更新数据库本身就已经解决了，所以基本不需要太多考虑。

5. 第二类丢失更新
有两个事务并发执行，事务A覆盖事务B提交的数据，造成事务B的操作丢失称为第二类丢失更新。
第二类丢失更新需要通过数据库事务之间的隔离级别进行处理。

##### 幻读和不可重复的区别：
* 幻读是指读到了其他已经提交事务的新增数据，防止新增数据。往往需要添加表级锁，Oracle和MySQL等成熟数据库采用多版本数据(MVCC)的方式实现
* 不可重复读是指读到了已经提交事务的更改数据(更改或删除)，防止读到更改数据，只需要对操作的数据添加行级锁，阻止操作中的数据发生变化

#### 数据库的锁机制
数据库并发会引发很多问题，数据库通过锁机制解决并发访问问题。
* 根据锁定对象的不同一般可以分为表级锁和行级锁，前者对整张表进行锁定，后者对表中特定行进行锁定。
* 根据锁定的关系来看，可以分为共享锁和独占锁。
* 根据所的实现原理可以分为悲观锁和乐观锁

#### 隔离级别
数据库定义了四个等级的事务隔离级别，分别是：
* 未提交读(Read Uncommitted)，允许脏读，也就是可以读取到其它会话中未提交事务修改的数据；
* 提交读(Read Committed), 只能读到已经提交的数据，可以解决脏读问题，Oracle数据库默认级别
* 可重复读(Repeated Read)：针对数据库里的同一条数据而言，可重复读会使得统一数据库记录的读/写按照一个序列化进行操作，不会产生交叉情况，可以防止不重复读的情况，Innodb的默认级别；
* 序列化(Serializable):完全串行化的读，每次读都需要获得表级共享锁，读写会互相阻塞，可以解决幻读。

#### 隔离级别的选择
推荐选择可重复读。

### Spring对于事务的支持
#### 声明式事务和编程式事务
编程式事务：所谓编程式事务是一种约定的事务，指的是通过编码方式实现事务，即类似于JDBC编程实现事务管理。换句话说，事务将有开发者通过自己的代码来实现，需要用到是一个事务定义类接口-TransactionDefinition，管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。现在基本不推荐使用。
声明式事务：管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。

#### Spring中的声明式事务
Spring的声明式事务是基于Spring AOP实现的，通过事务的声明性信息。Spring负责将事务管理增强逻辑动态织入业务方法的相应连接点中。
现在Spring主流的事务方式是声明式事务，主要有XML配置和注解配置两种形式。

1. 使用XML配置声明式事务
很少使用。
2. 使用注解配置声明式事务
通过@Transactional注解对需要事务增强的Bean接口、实现类或者方法进行批注；在容器中配置基于注解的事务增强驱动即可启用基于注解的声明式事务。
* 关于@Transactional的属性
    * 事务传播行为： 默认是REQUIRED
    * 事务的隔离级别LISOLATION_DEFAULT
    *  读写事务属性： 读/写事务
    *  超时时间： 依赖于底层的事务系统默认值
    * 回滚设置：任何运行期异常引发回滚，任何检查型异常不引发回滚
* 在何处使用@Transactional 
    * 虽然@Transactional可以使用在接口定义和接口方法‘、类定义和类的public方法上，但是Spring推荐用在业务实现类上。
    * 如果在方法处的注解会覆盖类定义处的注解

#### Spring事务的传播行为
Spring通过事务传播行为控制当前的事务如何传播到嵌套调用的目标服务，一个接口方法可能会在内部调用其他的接口方法共同完成一个完整的业务操作，因此就会产生服务接口方法嵌套调用的情况，Spring传播行为就是用来解决这个问题的。
Spring定义了7中类型的事务传播行为，规定了事务方法和事务方法之间发生嵌套调用时事务如何进行传播：
* REQUIRED ： 方法调用时，如果不存在当前事务，就创建事务，如果存在事务就沿用之前的事务。Spring默认级别
* SUPPORTS：支持当前事务。如果不存在当前事务，则以非事务的方式执行
* MANDATORY： 使用当前事务。如果当前没有事务，就抛出异常。
* REQUIRES_NEW:新建事务。无论是否有事务都会创建新的事务。如果当前有事务就把当前事务挂起。
* NOT_SUPPORTED： 以非事务的方式执行，如果当前存在事务就把当前事务挂起。
* NEVER:  以非事务的方式执行，如果当前存在事务就抛出异常。
* NESTED： 如果当前存在事务，则在嵌套事务内执行；如果当前没有事务则执行REQUIRED 。调用方法如果抛出异常只回滚自己内部执行的SQL，不回滚主方法的SQL，

### Mybatis的事务管理
Mybatis支持两种事务类型，分别为JdbcTransaction和ManagedTransaction。
对数据库的事务而言，应该具有以下几点：创建（create）、提交（commit）、回滚（rollback）、关闭（close）。对应地，MyBatis将事务抽象成了Transaction接口。







